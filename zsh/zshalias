# Enable aliases to be sudoâ€™ed
alias sudo='sudo '

# IP addresses
alias pubip="dig +short myip.opendns.com @resolver1.opendns.com"
alias localip="sudo ifconfig | grep -Eo 'inet (addr:)?([0-9]*\\.){3}[0-9]*' | grep -Eo '([0-9]*\\.){3}[0-9]*' | grep -v '127.0.0.1'"
alias ips="sudo ifconfig -a | grep -o 'inet6\\? \\(addr:\\)\\?\\s\\?\\(\\(\\([0-9]\\+\\.\\)\\{3\\}[0-9]\\+\\)\\|[a-fA-F0-9:]\\+\\)' | awk '{ sub(/inet6? (addr:)? ?/, \"\"); print }'"

# Flush Directory Service cache
alias flush="sudo killall -HUP mDNSResponder;sudo killall mDNSResponderHelper;sudo dscacheutil -flushcache"

# Merge PDF files
# Usage: `mergepdf -o output.pdf input{1,2,3}.pdf`
alias mergepdf='/System/Library/Automator/Combine\ PDF\ Pages.action/Contents/Resources/join.py'


# Docker aliases

if [ -f $ZSH_CONFIG_DIR/workalias ]
then
    source $ZSH_CONFIG_DIR/workalias
fi

alias dops="docker ps"

dobash() {
    docker exec -i -t $1 /bin/bash
}

dosh() {
    docker exec -i -t $1 /bin/sh
}

drsh() {
    docker run -i -t $1 /bin/sh
}

doclean() {
    docker images | awk '/none/ { print $3 }' | xargs docker rmi -f
    docker ps -a | awk '/Exited/ { print $1 }' | xargs docker rm -f
}

alias dormi="docker images --format '{{ .Repository }}:{{ .Tag }}' | peco --exec docker rmi -f"
alias dorm="docker ps --format '{{ .Name }}' | peco | xargs docker rm -f"
alias doi="docker images --format '{{ .Repository }}:{{ .Tag }}' | peco | pbcopy"

# compdef
_docker 2>/dev/null
compdef __docker_complete_running_containers dosh
compdef __docker_complete_running_containers dobash
compdef __docker_complete_images drsh
compdef __kubectl_complete_

# kubernetes
alias ka="kustomize build | kubectl apply -f -"
alias kb="kustomize build | less"
alias kdel="kustomize build | kubectl delete -f -"
alias ke="kubectl get events --sort-by=.metadata.creationTimestamp"
alias ns="kubens"
alias kx="kubectx"
alias kdiff="kustomize build | kubectl diff -f -"
alias kgsecreg='kgsec registry -o yaml | yq r - "data.[.dockerconfigjson]" | base64 -D'
alias kubeclean="kubectl config get-contexts | peco | awk '{ print \$1 }' | xargs -I _ kubectl config delete-context _"

kcrsecreg() {
   kubectl create secret docker-registry registry --docker-server=$1 --docker-username=$2 --docker-password="$3"
}

# Terraform
alias ti="terraform init"
alias tp="terraform plan"
alias tapp="terraform apply"

# system commands
alias df="df -H"
alias curl="gpg --batch -q -d ~/.authinfo.gpg | curl --netrc-file /dev/stdin"

# Changing Default programs
alias cat=ccat
if [[ "$(uname)" == "Darwin" ]]
then
alias wget=aria2c
fi
# fasd
alias j='fasd_cd -d'

# exa
alias ls='exa'

# find
alias find='fd'

# cd
alias ....='cd ../../../'
alias .....='cd ../../../../'

# Rest
function extract () {
      if [ -f $1 ] ; then
        case $1 in
          *.tar.bz2)   tar xjf $1     ;;
          *.tar.gz)    tar xzf $1     ;;
          *.bz2)       bunzip2 $1     ;;
          *.rar)       unrar e $1     ;;
          *.gz)        gunzip $1      ;;
          *.tar)       tar xf $1      ;;
          *.tbz2)      tar xjf $1     ;;
          *.tgz)       tar xzf $1     ;;
          *.zip)       unzip $1       ;;
          *.Z)         uncompress $1  ;;
          *.7z)        7z x $1        ;;
          *)     echo "'$1' cannot be extracted via extract()" ;;
           esac
       else
           echo "'$1' is not a valid file"
       fi
     }

function my-accept-line() {
  # check if the buffer does not contain any words
  if [ ${#${(z)BUFFER}} -eq 0 ]; then
    # put newline so that the output does not start next
    # to the prompt
    echo
      ls -l
  fi
  # in any case run the `accept-line' widget
  zle .accept-line
}
# create a widget from `my-accept-line' with the same name
zle -N accept-line my-accept-line
# rebind Enter, usually this is `^M'
bindkey '^M' accept-line

alias getmp3="youtube-dl -x --audio-format mp3 "
